/**
 * Copyright 2004-2017 Solace Corporation. All rights reserved.
 *
 */
package com.solacesystems.solclientj.core.samples;

import java.util.logging.Level;

import com.solacesystems.solclientj.core.SolEnum;
import com.solacesystems.solclientj.core.Solclient;
import com.solacesystems.solclientj.core.SolclientException;
import com.solacesystems.solclientj.core.event.SessionEventCallback;
import com.solacesystems.solclientj.core.handle.ContextHandle;
import com.solacesystems.solclientj.core.handle.MessageDispatchTargetHandle;
import com.solacesystems.solclientj.core.handle.MessageHandle;
import com.solacesystems.solclientj.core.handle.SessionHandle;
import com.solacesystems.solclientj.core.resource.Topic;
import com.solacesystems.solclientj.core.samples.common.AbstractSample;
import com.solacesystems.solclientj.core.samples.common.ArgumentsParser;
import com.solacesystems.solclientj.core.samples.common.SessionConfiguration;

/**
 * TopicDispatch.java
 * 
 * This sample demonstrates using local topicDispatch to direct received
 * messages into specialized received data paths.
 * <p>
 * 
 * This sample performs the following steps:
 * <ul>
 * <li>Adds subscription "a/>" to the Appliance to receive all messages with a
 * Topic prefix of "a/".
 * <li>Adds local dispatch function 1 for Topic "a/b"
 * <li>Add dispatch function 2 and subscription for "c/>"
 * <li>Add local dispatch function 3 for subscription "c/d"
 * <li>publish on Topic a/c and verify receipt only on session callback
 * <li>publish on Topic a/b and verify receipt only on dispatch function 1
 * <li>publish on Topic c/d and verify receipt on both dispatch functions 2 and
 * 3
 * <li>publish on Topic c/e and verify receipt on only dispatch function 2
 * </ul>
 * 
 * <strong>This sample illustrates the ease of use of concepts, and may not be
 * GC-free.<br>
 * See Perf* samples for GC-free examples. </strong>
 * 
 */
public class TopicDispatch extends AbstractSample {

	private SessionHandle sessionHandle = Solclient.Allocator
			.newSessionHandle();

	private ContextHandle contextHandle = Solclient.Allocator
			.newContextHandle();

	private MessageHandle txMessageHandle = Solclient.Allocator
			.newMessageHandle();

	private MessageDispatchTargetHandle messageDispatchTargetHandleTopic2;
	private MessageDispatchTargetHandle messageDispatchTargetHandleTopic3;
	private MessageDispatchTargetHandle messageDispatchTargetHandleTopic4;

	@Override
	protected void printUsage(boolean secureSession) {
		String usage = ArgumentsParser.getCommonUsage(secureSession);
		System.out.println(usage);
		finish(1);
	}

	/**
	 * This is the main method of the sample
	 */
	@Override
	protected void run(String[] args, SessionConfiguration config, Level logLevel)
			throws SolclientException {

	    

		// Init
		print(" Initializing the Java RTO Messaging API...");
		int rc = Solclient.init(new String[0]);
		assertReturnCode("Solclient.init()", rc, SolEnum.ReturnCode.OK);

		// Set a log level (not necessary as there is a default)
		Solclient.setLogLevel(logLevel);
		
		// Context
		print(" Creating a context ...");
		rc = Solclient.createContextForHandle(contextHandle, new String[0]);
		assertReturnCode("Solclient.createContext()", rc, SolEnum.ReturnCode.OK);

		/* Create a Session for sending/receiving messages. */
		print(" Create a Session for sending/receiving messages.");

		int spareRoom = 10;
		String[] sessionProps = getSessionProps(config, spareRoom);
		int sessionPropsIndex = sessionProps.length - spareRoom;

		/*
		 * Note: Reapplying subscriptions allows Sessions to reconnect after
		 * failure and have all their subscriptions automatically restored. For
		 * Sessions with many subscriptions this can increase the amount of time
		 * required for a successful reconnect.
		 */
		sessionProps[sessionPropsIndex++] = SessionHandle.PROPERTIES.REAPPLY_SUBSCRIPTIONS;
		sessionProps[sessionPropsIndex++] = SolEnum.BooleanValue.ENABLE;
		/*
		 * Note: Including meta data fields such as sender timestamp, sender ID,
		 * and sequence number will reduce the maximum attainable throughput as
		 * significant extra encoding/decoding is required. This is true whether
		 * the fields are autogenerated or manually added.
		 */
		sessionProps[sessionPropsIndex++] = SessionHandle.PROPERTIES.GENERATE_SEND_TIMESTAMPS;
		sessionProps[sessionPropsIndex++] = SolEnum.BooleanValue.ENABLE;
		sessionProps[sessionPropsIndex++] = SessionHandle.PROPERTIES.GENERATE_SENDER_ID;
		sessionProps[sessionPropsIndex++] = SolEnum.BooleanValue.ENABLE;
		sessionProps[sessionPropsIndex++] = SessionHandle.PROPERTIES.GENERATE_SEQUENCE_NUMBER;
		sessionProps[sessionPropsIndex++] = SolEnum.BooleanValue.ENABLE;

		/*************************************************************************
		 * Enable Topic Dispatch on the Session.
		 *************************************************************************/
		sessionProps[sessionPropsIndex++] = SessionHandle.PROPERTIES.TOPIC_DISPATCH;
		sessionProps[sessionPropsIndex++] = SolEnum.BooleanValue.ENABLE;

		SessionEventCallback sessionEventCallback = getDefaultSessionEventCallback();

		MessageCallbackSample messageCallback1 = new MessageCallbackSample(
				"session");

		/* Create the Session. */
		rc = contextHandle.createSessionForHandle(sessionHandle, sessionProps,
				messageCallback1, sessionEventCallback);
		assertReturnCode("contextHandle.createSession() - session", rc,
				SolEnum.ReturnCode.OK);

		/* Connect the Session. */
		print(" Connecting session ...");
		rc = sessionHandle.connect();
		assertReturnCode("sessionHandle.connect()", rc, SolEnum.ReturnCode.OK);

		/*************************************************************************
		 * Add Session subscription
		 *************************************************************************/
		String topic1Str = "a/>";
		print(" Adding subscription for Topic [" + topic1Str + "]");
		Topic topic1 = Solclient.Allocator.newTopic(topic1Str);
		rc = sessionHandle.subscribe(topic1,
				SolEnum.SubscribeFlags.WAIT_FOR_CONFIRM, 0);
		assertReturnCode("sessionHandle.subscribe() to topic " + topic1Str, rc,
				SolEnum.ReturnCode.OK);

		/*************************************************************************
		 * Add first dispatch function. This dispatch is local only (does not
		 * add the subscription on the Appliance).
		 *************************************************************************/

		String topic2Str = "a/b";
		print(" Adding subscription for Topic [" + topic2Str + "]");
		Topic topic2 = Solclient.Allocator.newTopic(topic2Str);

		MessageCallbackSample messageCallback2 = new MessageCallbackSample(
				topic2Str);
		messageDispatchTargetHandleTopic2 = Solclient.Allocator
				.newMessageDispatchTargetHandle(topic2, messageCallback2, true);

		rc = sessionHandle.subscribe(messageDispatchTargetHandleTopic2, 0, 0);
		assertReturnCode(
				"sessionHandle.subscribe with a MessageDispatchTargetHandle for topic "
						+ topic2Str, rc, SolEnum.ReturnCode.OK);

		/*************************************************************************
		 * Add second dispatch function. This dispatch includes adding the
		 * subscription to the Appliance.
		 *************************************************************************/
		String topic3Str = "c/>";
		print(" Adding subscription for Topic [" + topic3Str + "]");
		Topic topic3 = Solclient.Allocator.newTopic(topic3Str);

		MessageCallbackSample messageCallback3 = new MessageCallbackSample(
				topic3Str);
		messageDispatchTargetHandleTopic3 = Solclient.Allocator
				.newMessageDispatchTargetHandle(topic3, messageCallback3, false);

		rc = sessionHandle.subscribe(messageDispatchTargetHandleTopic3,
				SolEnum.SubscribeFlags.WAIT_FOR_CONFIRM, 0);
		assertReturnCode(
				"sessionHandle.subscribe with a MessageDispatchTargetHandle for topic "
						+ topic3Str, rc, SolEnum.ReturnCode.OK);

		/*************************************************************************
		 * Add third dispatch function. This dispatch is local only (no
		 * subscription is added to Appliance).
		 *************************************************************************/
		String topic4Str = "c/d";
		print(" Adding subscription for Topic [" + topic4Str + "]");
		Topic topic4 = Solclient.Allocator.newTopic(topic4Str);

		MessageCallbackSample messageCallback4 = new MessageCallbackSample(
				topic4Str);
		messageDispatchTargetHandleTopic4 = Solclient.Allocator
				.newMessageDispatchTargetHandle(topic4, messageCallback4, true);

		rc = sessionHandle.subscribe(messageDispatchTargetHandleTopic4, 0, 0);
		assertReturnCode(
				"sessionHandle.subscribe with a MessageDispatchTargetHandle for topic "
						+ topic4Str, rc, SolEnum.ReturnCode.OK);

		/*************************************************************************
		 * Publish a message on each of the four Topics
		 *************************************************************************/

		print("Publishing messages");
		common_publishMessage(sessionHandle, txMessageHandle, "a/c",
				SolEnum.MessageDeliveryMode.DIRECT);
		common_publishMessage(sessionHandle, txMessageHandle, "a/b",
				SolEnum.MessageDeliveryMode.DIRECT);
		common_publishMessage(sessionHandle, txMessageHandle, "c/d",
				SolEnum.MessageDeliveryMode.DIRECT);
		common_publishMessage(sessionHandle, txMessageHandle, "c/e",
				SolEnum.MessageDeliveryMode.DIRECT);

		/*************************************************************************
		 * Pause to let messages return
		 *************************************************************************/
		try {
			Thread.sleep(1000);
		} catch (InterruptedException e) {
			e.printStackTrace();
		}

		/*************************************************************************
		 * Verify expected results
		 *************************************************************************/
		if (messageCallback1.getMessageCount() == 1) {
			print("Received exactly one message on session callback as expected");
		} else {
			throw new IllegalStateException(String.format(
					"Received %d message(s) on session callback - 1 expected",
					messageCallback1.getMessageCount()));
		}
		if (messageCallback2.getMessageCount() == 1) {
			print("Received exactly one message on dispatch callback for topic 'a/b' as expected");
		} else {
			throw new IllegalStateException(
					String.format(
							"Received %d message(s) on dispatch callback for topic 'a/b' - 1 expected",
							messageCallback2.getMessageCount()));
		}
		if (messageCallback3.getMessageCount() == 2) {
			print("Received exactly two messages on dispatch callback for topic 'c/>' as expected");
		} else {
			throw new IllegalStateException(
					String.format(
							"Received %d message(s) on dispatch callback for topic 'c/>' - 2 expected",
							messageCallback3.getMessageCount()));
		}
		if (messageCallback4.getMessageCount() == 1) {
			print("Received exactly one message on dispatch callback for topic 'c/d' as expected");
		} else {
			throw new IllegalStateException(
					String.format(
							"Received %d message(s) on dispatch callback for topic 'c/d' - 1 expected",
							messageCallback4.getMessageCount()));
		}

		print("Run() DONE");
	}

	/**
	 * Invoked when the sample finishes
	 */
	@Override
	protected void finish(int status) {

		/*************************************************************************
		 * Cleanup
		 *************************************************************************/

		finish_DestroyHandle(messageDispatchTargetHandleTopic2,
				"messageDispatchTargetHandleTopic2");

		finish_DestroyHandle(messageDispatchTargetHandleTopic3,
				"messageDispatchTargetHandleTopic3");

		finish_DestroyHandle(messageDispatchTargetHandleTopic4,
				"messageDispatchTargetHandleTopic4");

		finish_DestroyHandle(txMessageHandle, "messageHandle");

		finish_Disconnect(sessionHandle);

		finish_DestroyHandle(sessionHandle, "sessionHandle");

		finish_DestroyHandle(contextHandle, "contextHandle");

		finish_Solclient();
	}

/**
     * Boilerplate, calls {@link #run(String[])
     * @param args
     */
	public static void main(String[] args) {
		TopicDispatch sample = new TopicDispatch();
		sample.run(args);
	}

}
